源码的完整处理流程（以 Hybrid 混合方法为例）：

1. 加载数据 (load_dark_frames)
    动作： 将你拍好的多张全黑 16-bit RAW 格式图像读取到内存中，堆叠成一个三维矩阵（时间帧数 $\times$ 高 $\times$ 宽）。

2. 核心计算预处理（分离与统计）
    动作： 首先沿着时间轴，计算出这批图像的时间均值图、时间方差图等。
    关键拆分： 调用 _split_bayer，将均值图和方差图“撕”成 R, Gr, Gb, B 四张只有同色像素的小图。后续所有计算都在这四个独立通道内并行展开。

3. 多维度缺陷检测 (_detect_hybrid 调用的三个子域)
    统计域 (_detect_statistical)： 在每个颜色通道内，计算局部（比如 $5\times5$ 同色邻域）的均值和标准差。如果某个像素比它周围的同色兄弟亮出好几个标准差，或者它绝对值大得离谱（超过 99.9% 分位数），就标记为嫌疑坏点。
    时间域 (_detect_temporal)： 观察像素随时间的变化。死点 (Dead) 无论怎么拍都是暗的，时间方差几乎为 0；亮点 (Hot) 由于热噪声不稳定，时间方差会异常大。
    空间域 (_detect_spatial)： 对同色通道做中值滤波，如果一个像素的值跟它周围同色邻居的“中位数”差异巨大，说明它是空间上的孤立异常点。

4. 交叉验证与合并 (vote_count >= 2 与 _merge_bayer)
    动作： 把上述三个维度测出来的嫌疑地图叠在一起投票。只有至少在两个维度中都被判定为异常的像素，才被最终确认为“真坏点”。
    合并：调用 _merge_bayer 将 4 个通道的坏点地图拼回原来 1280x800 的大地图。

5. 后处理与滤除误报 (binary_opening)
    动作： 真实传感器的坏点通常是散落的单点，或者坏了一整条线。如果是大面积成簇的标记，往往是检测算法的误报。使用形态学开运算（Morphological Opening）抹去一些孤立的噪点误判。

6. 分类与报告生成 (_classify_defects & generate_report)
    动作： 拿着最终确认的坏点坐标，回头去查它们的值。极暗且没方差的归为 Dead，极亮的归为 Hot，剩下的归为 Stuck。
    输出一个 .npy 二进制矩阵文件供 C++ 工程直接调用，并画出热力图、直方图（_plot_analysis）供开发者评估传感器健康状态。